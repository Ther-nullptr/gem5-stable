# Spectre Attacks

参考文献：[^1][^2][^3]

## 关键词

branch prediction: 分支预测

speculative execution: 推测性执行

spectre attack: 幽灵攻击

transient instructions: 瞬时指令

gadget: 小程序，小工具

BTB: branch target buffer，分支目标缓冲区

RSB: return stack buffer，返回堆栈缓冲区

side-channel attack: 侧信道攻击

cache coherence protocol: 缓存一致性协议

## 背景

### jump instructions

分支跳转指令分为3种：

* Direct Calls and Jumps：跳转时直接设置PC的值
* Indirect Calls and Jumps：跳转时不直接设置PC值，而是将当前PC值加上一定的偏移量
* Conditional Branches：根据分支跳转

分支目标缓冲区（BTB）保留了从最近执行的分支指令的地址到目标地址的映射[44]。处理器可以使用BTB来预测未来的代码地址，甚至在对分支指令进行解码之前。

对于本文重点讲述的Conditional Branches，记录目标地址对于预测分支的输出结果是没有必要的，因为目的地通常是在指令中编码的，而条件是在运行时确定的。为了提高预测能力，处理器保持了一个分支结果的记录。

对于Indirect Calls and Jumps中的return指令，多使用RSB，其保持了一份最近使用的调用堆栈部分的副本。如果RSB中没有可用的数据，不同的处理器会拖延执行或使用BTB作为后备。

### Cache

现代Intel处理器有三个缓存级别，每个内核都有专用的L1和L2缓存，所有内核共享一个共同的L3缓存，也被称为最后一级缓存（LLC）。缓存将内存分成固定大小的块，称为行，典型的行大小为64或128字节。

### side channel attack

本文提到的侧信道攻击基于cache，有两种主要方法：

* Flush+Reload：通过对比某数据的访问延迟，从而推测出该数据是否被加载到 cache 中。具体来讲：

  1. Attacker先通过Flush清空对应的cache line

  2. 触发Victim访问该数据

  3. Attacker会访问同一数据并测量访问时间

* Evict+Reload：优点在于不需要执行flush指令，不过具体没看。

## 概述

现代处理器使用分支预测和推测性执行来最大化性能。例如，如果一个分支的目的地取决于正在读取的内存值，CPU将试图猜测目的地并尝试提前执行。如果分支成立，则CPU会提交投机性计算；如果分支不成立，则CPU会丢弃推测性执行。

> 分支预测和推测性执行的必要性：考虑一个例子，程序的控制流程依赖于位于外部物理内存中的一个未缓存的值。由于这个内存的速度比CPU慢得多，往往需要几百个时钟周期才能知道这个值。与其空转浪费这些周期，CPU试图猜测控制流的方向，保存其寄存器状态的检查点，并继续在猜测的路径上推测地执行程序。

> 推测性执行的步骤：当数值最终从内存中到达时，CPU会检查其初始猜测的正确性。如果猜测是错误的，CPU就会通过将寄存器状态恢复到存储的检查点来放弃错误的投机执行，从而使性能与空闲时相当。然而，如果猜测是正确的，投机执行的结果就会被提交，产生一个显著的性能增益。

幽灵攻击的基本原理是诱导受害者推测性执行在正确的程序执行过程中不会发生的操作，这些操作通过侧信道向对手泄露受害者的机密信息。这些操作对CPU的最终状态不会造成影响（如果不正确会被撤回），因此被叫做瞬时指令。

> 虽然这种错误的投机执行所导致的对CPU名义状态的改变最终会被还原，但之前泄露的信息或对CPU其他微架构状态的改变，如缓存内容，可以在名义状态还原后继续存在，所以也不能叫完全不变。

## 基本步骤

1. 创建一个简单的受害者程序，该程序在其内存地址空间中包含秘密数据。
2. 在binary和shared library中，搜索可以用来泄露受害者地址空间信息的指令序列。
3. 编写一个攻击者程序，利用CPU的投机执行功能，将之前发现的序列作为瞬时指令执行。
4. 通过秘密通道泄露受并检索出受害者的信息。

## 变种

### 变种1: 利用条件性分支

攻击者误导CPU的分支预测器，使其错误预测分支的方向，导致CPU暂时违反程序语义，执行本来不会被执行的代码。

以以下C代码为例，这里`array2`的大小为1MB：

```c++
if (x < array1_size)
{
    y = array2[array1[x] * 4096];
}
```

1. 攻击者用有效的输入调用上述代码，从而训练分支预测器，使其预期if将为真(mistraining)。
2. 攻击者用超出array1边界的x值调用代码。CPU没有等待分支结果的确定，而是猜测边界检查将是真实的，并推测执行块内语句(exploit)。
3. 通过已经越界的x读取潜在的秘密字节后，当最终确定边界检查的结果时，CPU发现了它的错误，并恢复了对其名义微架构状态的任何改变。然而，对缓存状态所做的改变不会被恢复。
4. 攻击者可以分析缓存内容，并找到从受害者的内存中越界读取的潜在秘密字节的值。

注意这块有一个trick：取`array2`的数据时，index是`array[x] * 4096`，确保数据按比例访问到不同的缓存行，以避免**硬件预取效应**。

读取`array1_size`会导致缓存缺失，处理器会面临很大的延迟。所以处理器会先行预测分支。如果分支被正确预测，自然会导致很快的执行速度；但如果发生错误的话：

* `array1[x]`发生越界，`array1[x]`就会解析为受害者内存中的某个秘密字节k。
* `array1_size` 和 `array2` 都没有在缓存中，但秘密字节k被存放在缓存中，这是因为调用`array1[x]`时秘密字节被取了一次，之后在取`array2`中的字节时又需要被取用一次。
* 之前接收到的x可能为有效值（即未越界），导致在出现非法值时也预测为真。

> 借鉴知乎某人的回答，总结一下实现攻击的必要条件：
>
> 1. attacker需要在victim中找到该段代码。
> 2. attacker需要能够控制变量x。
> 3. attacker需要能够访问array2, 否则没有side channel。
> 4. array2不在cache, 这是旁路攻击使用Flush+Reload的前提。
> 5. array1_size不在cache, 这样条件指令所需时间更长, 有利于投机执行; array1[x]在cache, 这样array2[array1[x] \* 4096]才能尽早发出。
>
> 为了完成攻击，对手测量array2中的哪个位置被带入cache（注意到array2原先不在cache中），这样就可以推测出array1[x]的值（也就是k）的值。4096避免了所谓的硬件预取效应——假如该数组是int32，那么当index相差4096时，地址差了4096\*4 = 16384 bytes，差不多对应一个16K的l1 cache，这就排除了重叠的可能。

### 变种2: 利用间接分支

1. 攻击者从受害者的地址空间中选择一个小程序。
2. 训练分支目标缓冲区（BTB）来错误预测从间接分支指令到小程序地址的分支，导致小程序的投机执行。为了误导BTB，攻击者在受害者的地址空间找到小工具的虚拟地址，然后对这个地址进行间接分支。这个训练是在攻击者的地址空间完成的。
3. 小工具通过缓存侧通道泄露敏感信息。

这一变种类似于return-oriented programming（见CSAPP的Attacklab）。

## 预防措施

1. 避免推测性执行（目前的处理器没有允许软件禁用投机执行的方法，并不现实，而且会带来性能的显著下降；插入序列化指令等需要更新现有软件）。
2. 防止对秘密数据的访问（如对数组索引应用了一个比特屏蔽，确保它不比数组的大小大很多）。
3. 防止数据进入秘密渠道（处理器将会对推测性执行的数据进行追踪，防止其被用于可能泄漏的后续操作，不过目前处理器还不具备这个能力）。
4. 限制从隐蔽渠道提取的数据。
5. 避免分支中毒（在ISA中扩展控制间接分支的机制）。

## 参考文献

[^1]: [解读 Meltdown & Spectre CPU 漏洞](https://zhuanlan.zhihu.com/p/32757727)

[^2]: [迟到的Meltdown/Spectre分析](https://zhuanlan.zhihu.com/p/263081764)

[^3]: [旁路攻击](https://zh.wikipedia.org/zh-cn/%E6%97%81%E8%B7%AF%E6%94%BB%E5%87%BB)

[^4]: [Spectre Attacks: Exploiting Speculative Execution. 2019](https://blog.csdn.net/diamond_biu/article/details/123578828)

